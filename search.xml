<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图片img标签src=[object Module]]]></title>
    <url>%2F2019%2F12%2F18%2F%E5%9B%BE%E7%89%87img%E6%A0%87%E7%AD%BEsrc-object-Module%2F</url>
    <content type="text"><![CDATA[在使用webpack4初始化项目，基础配置完之后出现的一个问题。如下图img属性src=”[object Module]”，引入图片的方式为配置的图片loader试了两种都不行：file-loader、url-loader配置如下解决办法 在options里面加入1esModule: false如果你是用的url-loader那就在url-loader里面的options配置 作用是启用CommonJS模块语法具体的原理不是很懂，如果读者明白望告知。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目以及答案]]></title>
    <url>%2F2019%2F12%2F04%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E4%BB%A5%E5%8F%8A%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[底下网盘自取面试题1.window.location以下URL地址为自编，方便示例 href（返回整个URL地址，就是浏览器地址栏的内容）window.location.href：返回值：http://www.san.com:8000/hello.js?t=3dg&amp;id=utf-8#hello（随便编的一个地址）protocol（URL协议）window.location.protocol：返回值：httphost（URL主机部分）window.location.host：返回值：www.san.comhostname（URL主机部分加上端口号）window.location.hostname：返回值：www.san.com:8000pathname（URL路径部分，即文件地址）window.location.pathname：返回值：/hello.jshash（锚点）window.location.hash：返回值：#hellosearch（URL参数部分）window.location.search：返回值：?t=3dg&amp;id=utf-8 2.setTimeout与setInterval的区别setTimeout是几秒过后执行，只执行一次。setInterval 是每隔几秒执行一次。12345678910&lt;script&gt;window.onload=function()&#123; var a = setInterval(function()&#123; console.log('123') &#125;,1000) var b = setTimeout(function()&#123; console.log('abc') &#125;,1000)&#125;&lt;/script&gt; 写法window.setInterval(“执行的函数”,“执行的时间(毫秒)”);setInterval(fun,1000);//每隔一秒执行一次函数；setInterval(“fun()”,1000);//可以用但不推荐；setInterval(function(){},1000); 3.如何得到地址栏URL以及其各个参数使用wndow.location.href得到地址通过split方法遍历得到或者使用 window.location.search 获得”?”后面的字符串，然后通过 split 方法结合循环遍历自由组织数据格式.12345678910111213141516var url = '?name=12&amp;age=23'; function urlQueryString(url) &#123; var url = url.split('?')[1].split('&amp;'); var len = url.length; this.url = &#123;&#125;; for(var i=0; i&lt;len; i++) &#123; var cell = url[i].split('='), key = cell[0], val = cell[1]; this.url[''+key+''] = val; &#125; return this.url; //return this.url.name or this.url.name &#125; console.log(urlQueryString(url)); //返回的是一个对象&#123;name:"12",age:""23&#125; 4.js中数组有哪些方法及其含义pop()数组尾部删除push()数组尾部添加unshift()数组头部添加shift()数组头部删除join()将数组元素连接起来以构建一个字符串sort()对数组元素进行排序reverse()颠倒数组中元素的顺序concat()连接数组slice()返回数组的一部分splice()插入、删除或替换数组的元素reduce()和 reduceRight() （ES5新增）toLocaleString( ) 把数组转换成局部字符串toString( ) 将数组转换成一个字符串indexOf()和 lastIndexOf() （ES5新增）forEach() （ES5新增）map() （ES5新增）filter() （ES5新增）every() （ES5新增）some() （ES5新增） 5.jquery中$.ajax的常用参数有哪些？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849type 类型：String 默认值: "GET")。请求方式 ("POST" 或 "GET")， 默认为 "GET"。注意：其它 HTTP 请求 方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url 类型：String 默认值: 当前页地址。发送请求的地址。 success 类型：Function 请求成功后的回调函数。 参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。 这是一个 Ajax 事件。 options 类型：Object 可选。AJAX 请求设置。所有选项都是可选的。 async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置 为 false。 注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR) 类型：Function 发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。 XMLHttpRequest 对象是唯一的参数。 这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache 类型：Boolean 默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页 面。 jQuery 1.2 新功能。 contentType 类型：String 默认值: "application/x-www-form-urlencoded"。发送信息至服务器时内容编码类型。 默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发 送给服务器（即使没有数据要发送）。 data 类型：String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将 自动为不同值对应同一个名称。如 &#123;foo:["bar1", "bar2"]&#125; 转换为 '&amp;foo=bar1&amp;foo=bar2'。 dataFilter 类型：Function 给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType 类型：String 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判 断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对 象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调 函数。可用值:  "xml": 返回 XML 文档，可用 jQuery 处理。  "html": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。  "script": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 "cache" 参数。 注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将 使用 DOM 的 script 标签来加载）  "json": 返回 JSON 数据 。  "jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。  "text": 返回纯文本字符串 error 类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 "timeout", "error", "notmodified" 和 "parsererror"。 这是一个 Ajax 事件。 6.http状态码有哪些及其含义100 - 继续。客户端应继续其请求101 - 切换协议200 - 请求成功201 - 已创建。成功请求并创建了新的资源301 - 资源（网页等）被永久转移到其它 URL302 - 临时移动。与301类似。但资源只是临时被移动。303 - 查看其它地址。与301类似。使用GET和POST请求查看304 - 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源307 - 临时重定向。与302类似。使用GET请求重定向403 - 服务器理解请求客户端的请求，但是拒绝执行此请求404 - 请求的资源（网页等）不存在500 - 内部服务器错误502 - 服务器处于停机或维护 7.说一下你对闭包的理解，简单写一个闭包闭包简单来说，每个函数都可以说是一个闭包，闭包能够拥有属于自己的私有变量，闭包的意义是函数外部可以访问函数内部的变量（如果讲的不太好希望C友补充纠正）。滥用闭包会造成内存泄漏。例子123456789function outer()&#123; var num = 1; function inner()&#123; var n = 2; alert(n + num); &#125; return inner; &#125; outer()(); 8.Vue中v-if跟v-show的区别从两个方面来说：1、渲染方面：v-if使用后节点是完全删除，而v-show还存在（跟display：none和visibility：hidden的区别一样）。2、性能方面：比如说你的页面有一个按钮，需要添加以及删除，如果使用v-if会反复的删除添加消耗大，而v-show则不会，因为他还保留者节点，只是显示跟隐藏起来，还占据空间。 9.数组去重+字符串去重（一）数组去重1、通过判断对象是否存在该属性(对应数组的键值)，如果存在将该属性加入新数组，否则不做操作。123456789var arr = [1,1,2,3,3,5]; var result = &#123;&#125;; var arr2 = []; for(var i=0;i&lt;arr.length;i++)&#123; if(!result[arr[i]])&#123; result[arr[i]] = 1; arr2.push(arr[i]); &#125; console.log(arr2); 2、利用ES6的Set数据结构的性质：成员的值都是唯一性(Set类似数组，本身是构造函数)以下是Set的两种方式123456789101112方式(一)let set = new Set([2, 2, 3, 4, 4,6,6]); console.log([...set]) //[2,3,4,6]//或者这样写let arr = [2,2,3,4,4,6,6]let set = new Set(arr); console.log([...set]) //[2,3,4,6]方式(二)console.log( Array.from(new Set([2,2,3,3,4,4,6,6])) ) //[2,3,4,6]等价于let set = new Set([2, 2, 3, 4, 4，6,6]); console.log( Array.from(set)) （二）字符串去重12345let str = "addssebbc";let set = new Set((str));console.log([...set].join(''));//输出adsebc或者[...new Set('addssebbc')].join('') 10.水平垂直居中的几种方式详情请看文章css垂直居中浮动元素 11.用户从输入浏览器地址到渲染页面都执行了什么结合这两篇文章，你会很清晰文章一文章二 11.同步与异步的区别，阻塞与非阻塞的区别同步（阻塞的）：浏览器向服务器请求数据，服务器很忙，浏览器一直等着，直到服务器返回数据，浏览器才显示页面异步（非阻塞）：浏览器向服务器请求数据，服务器很忙，浏览器可以自主的做其他事情，不用一直等着，等服务器响应请求的时候，再通知浏览器，浏览器把返回的数据再渲染到页面上 12、Webworkers、websocketWebworkers是运行在后天的javascript，不影响页面的性能，webworkers是一个javascript多线程的解决方案。webworkers的原理是，在javascript主线程中通过worker类加载一个js文件重新开辟一个进程，主要使用postMessage()跟onmessage()这两个方法进行通信。查看代码例子websocket是一个通信协议，可以使服务端主动的向客户端推送数据，它只需要进行一次握手就可以创持久的连接，与TCP协议不同。 13、http常见缓存请求头强缓存：Expires，Cache-control对比缓存（协商缓存，弱缓存）: Last-Modified，Etag按下F12，点击Network，再点击请求文件就可以看到相关请求头 14、http缓存机制15、普通事件跟事件绑定的区别普通事件不支持添加多个事件而且最下面的事件会覆盖掉上面的事件，而事件绑定可以添加多个事件。普通事件：var div = document.getElementById(“div”);div.οnclick=funcition(){console.log(“123”);}div.οnclick=funcition(){console.log(“abc”);}只输出abc事件绑定：var div = document.getElementById(“div”);div.addEventListener(“click”,function(){console.log(132)’},false);div.addEventListener(“click”,function(){console.log(“abc”)},false);依次执行输出132，abc； 15、事件冒泡、事件委托、事件捕获事件冒泡会从当前的事件目标一层一层的往上传递，依次触发，知道document为之；事件捕获则是从doucument开始，一层一层往下传递，直到具体目标事件为止。事件委托是利用事件冒泡的原理，让父元素代为执行事件。（主要是减少dom操作） 16、阻止事件冒泡和默认事件阻止事件冒泡：e.stopPropagation();//标准浏览器；event.cancebubble=true；阻止默认事件：e.preventDefault) || return false 17、javascript的本地对象本地对象为 array obj regexp 等可以 new 实例化内置对象为 gload Math 等不可以实例化的宿主为浏览器自带的 document,window 等window：window表示一个浏览器窗口或是一个框架，是js的最高级对象；同时包含document、history、location三个子对象；doucument：每个载入浏览器的 HTML 文档都会成为 Document 对象，Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问，可通过 window.document 属性对其进行访问；history：包含用户（在浏览器窗口中）访问过的 URL。location：包含有关当前 URL 的信息。（详细见本篇第一条） 18、for … in 与for … of的区别前者获取键名，后者获取键值12345678let arr = ['1', 'a', '2', 'd']; for (let i in arr) &#123; console.log(i); // 0 1 2 3 这里获取的相当于是数组的下标 &#125; for (let iof arr) &#123; console.log(i); // 1，a，2，d //这里是获取的数组的下标对应的值 &#125; 19、深拷贝与浅拷贝1234567891011121314151617181920212223242526272829303132333435//深拷贝:b复制了a，改变了a，b也会跟着改变。 //浅拷贝:b复制了a，改变了a，b不改变。 /** 深拷贝 **/ function deepClone(obj)&#123; var newobj = Array.isArray(obj) ? [] : &#123;&#125;; //判断是否数组 if(obj &amp;&amp; typeof obj === 'object') &#123; //判断类型是否object，为不为空； for(var key in obj) &#123; // 判断子元素是否为object对象 if(obj[key] &amp;&amp; typeof obj[key] === 'object')&#123; //子元素递归一遍赋值 newobj[key] = deepClone(obj[key]); &#125;else &#123; newobj[key] = obj[key]; //普通赋值 &#125; &#125; &#125; return newobj; &#125; var a = [1,2,3,4]; var b = deepClone(a); a[2] = 9; console.log(a);//[1,2,9,4] console.log(b);//[1,2,3,4] var c = [1,2,[3,4],5]; var d = deepClone(c); c[2][0] = 10; console.log(c); //[1,2,[10,4],5] console.log(d); //[1,2,[3,4],5] //从上面可以看出该函数实现了单层(a,b)，多层(c,d)的深拷贝 /* **/ 1234567891011121314/* 利用JSON.stringify与JSON.parse实现深拷贝 */ function JsondeepClone(obj) &#123; var objnew = JSON.stringify(obj); var objresult = JSON.parse(objnew); return objresult; &#125; var e = [1,2,3,[4,5],6]; var f = JsondeepClone(e); e[3][0] = 7; console.log(e); //[1,2,3,[7,5],6]; console.log(f); //[1,2,3,[4,5],6]; /* **/ 12345678910111213141516/* jquery extend实现深拷贝与浅拷贝 $.extend( [deep ], target, object1 [, objectN ] ) deep:可选，Boolean默认false，true表示深拷贝，false表示浅拷贝 target:目标对象，其他对象的成员将附加到该对象上； object1:可选，object类型，第一个被合并的对象 objectN:可选，object类型，第N个被合并的对象 **/ var hh = [1,2,[3,4,5]]; var jj = $.extend(true,[],hh); var zz = $.extend(false,[],hh); hh[2][0] = 7; console.log(hh); //[1,2,[7,4,5]] console.log(jj); //[1,2,[3,4,5]] console.log(zz); //&#123;0:1,1:2,2:[7,4,5]&#125;这里我也不知道为什么输出是对象形式 /* **/ 12345678910111213141516171819202122232425262728/* 单层深拷贝slice,concat，assign; */ var aa = [1,2,3,4]; var bb = aa.slice(); var cc = aa.concat(); aa[0] = 2; console.log(aa); //[2,2,3,4] console.log(bb); //[1,2,3,4] console.log(cc); //[1,2,3,4] //上面可以看到单层的，slice，concat可以实现深拷贝，看看多层可否 var dd = [1,2,[3,4],5]; var ee = dd.slice(); var ff = dd.concat(); dd[2][0] = 9; console.log(dd); //[1,2,[9,4],5] console.log(ee); //[1,2,[9,4],5] console.log(ff); //[1,2,[9,4],5] //可以看到多层,有二级属性时,slice，concat无法实现深拷贝； var xx = [1,2,[4,5,6]]; var ww = Object.assign([],xx); xx[0] = 2; xx[2][0] = 11; console.log(xx); //[2,2,[11,5,6]] console.log(ww); //[1,2,[11,5,6]] //由此可见Object.assign实现的也是浅层拷贝； /* **/ 更多面试题 这里面有一个pdf文件（包含html，css，ajax，jquery，js）面试题链接：https://pan.baidu.com/s/1qUrlj0bWcU1eJJovMTVJ_Q提取码：bydm]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css垂直居中浮动元素]]></title>
    <url>%2F2019%2F12%2F04%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1、flex布局垂直居中1234567.div &#123; display: flex; justify-content: center; /* 水平居中 */ align-items: center; /* 垂直居中 */ width: 1000px; height: 600px; &#125; 2、绝对定位垂直居中已知子元素宽高123456789.div1&#123; width:200px; height:200px; position:absolute;//父元素要相对定位 left:50%; top:50%; margin-left:-100px;//自身宽高一半的复负值 margin-top:-100px;&#125; 未知元素的宽高12345678910.div2&#123; width:200px; height:200px; position:absolute;//父元素要相对定位 margin:auto; left:0; right:0; top:0; bottom:0;&#125; 123456789.div3&#123;position: absolute;left: 50%;transform: translateX(-50%); /* 移动元素本身50% */&#125; 12345.div4&#123; display:table-cell; vertical-align: middle; text-align: center;&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
